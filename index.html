<meta charset="utf-8">
<head>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
</head>
<body>

    <div id="container"></div>
    <button onclick="create_a_new_one()" >gimme a new one</button>

<script>

function run_function_and_measure_runtime(func,name)
{
    let t0 = performance.now();

    func();

    let t1 = performance.now();

    console.log("function " + name +" needed " + (t1-t0)+ " milliseconds");
    
}


var sites = [];
var clusters = [];
let nnz_positions = [];
let pixel_width = 1;
let size_of_cluster = {};

let p = 0.59274,
    sidelength = 1000;
p = 0.59; 
let N = sidelength*sidelength;
let n_clusters = 0;
let color = d3.scaleOrdinal(d3.schemeDark2);

var width = sidelength*pixel_width, i
    height = sidelength*pixel_width;
var canvas = d3.select('#container')
  .append('canvas')
  .attr('width', width)
  .attr('height', height);

var ctx = canvas.node().getContext('2d');
var transform = d3.zoomIdentity;




var main_timer;

var updates_per_frame = 15;


function create_a_new_one() {
    run_function_and_measure_runtime(init,"init");
    run_function_and_measure_runtime(update,"update");
    run_function_and_measure_runtime(draw,"draw");
}

create_a_new_one();

canvas
    //.call(d3.drag().subject(dragsubject).on("drag", dragged))
    .call(d3.zoom().scaleExtent([1, 8]).on("zoom", zoomed))
    .call(draw);

function zoomed() {
  transform = d3.event.transform;
  draw();
}


//function play() {
//    main_timer = d3.interval(function() {
//            draw();
//            }, 100);
//}

function fill4(x_,y_,this_cluster) {
    let stack = [ [x_,y_] ];

    while (stack.length > 0)
    {
        let pos = stack.pop();
        let x = pos[0];
        let y = pos[1];
        if ((sites[index(x,y)] == 1) && clusters[index(x,y)] == -1)
        {
            clusters[index(x,y)] = this_cluster;
            size_of_cluster[this_cluster]++;

            if (y+1 < sidelength)
                stack.push([x,y+1]);
            if (y-1 >= 0)
                stack.push([x,y-1]);
            if (x+1 < sidelength)
                stack.push([x+1,y]);
            if (x-1 >= 0)
                stack.push([x-1,y]);
        }
    }
}


function update() {

    nnz_positions.forEach(function(pos) {
        let x = pos[0];
        let y = pos[1];
        let this_cluster = n_clusters;
        if (clusters[index(x,y)] < 0)
        {
            size_of_cluster[this_cluster] = 0;
            fill4(x,y,this_cluster);
            n_clusters++;
        }

    });

}

function draw() {
    ctx.save();

    // delete all that was drawn
    let bg_val = 0;
    ctx.fillStyle = "rgb("+bg_val+","+bg_val+","+bg_val+")";
    ctx.fillRect( 0, 0, width, height );
    ctx.translate(transform.x, transform.y);
    ctx.scale(transform.k, transform.k);

    nnz_positions.forEach(function(pos) {
        let x = pos[0];
        let y = pos[1];
        let this_cluster = clusters[index(x,y)];
        ctx.fillStyle = color(this_cluster);
        ctx.fillRect( x*pixel_width, y*pixel_width, pixel_width, pixel_width );

    });
    ctx.restore();
}

function index(i,j){
    return i * sidelength + j;
}

function init(){
    sites.length = 0;
    clusters.length = 0;
    nnz_positions.length = 0;
    size_of_cluster = {};
    for(let i=0; i<sidelength; i++)
    {
        for(let j=0; j<sidelength; j++)
        {
            if (Math.random() < p)
            {
                nnz_positions.push([i,j]);
                sites.push(1);
            }
            else
            {
                sites.push(0);
            }
            clusters.push(-1);
        }
    }
}

</script>



</body>
